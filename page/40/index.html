<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/40/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/40/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/09/leetcode-8-string-to-integer-atoi/">LeetCode 8. String to Integer (atoi)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 9, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
</blockquote>
<p>比较简单的题目, 因为要转换的是整数, 因此只需要考虑前导空格和符号.</p>
<p>代码:</p>
<pre><code>class Solution {
public:
    bool isNumber(char a){
        return a &gt;= '0' &amp;&amp; a &lt;= '9';
    }

    int myAtoi(string str) {
        int len = str.length(), p = 0;
        if(str[0] == ' '){
            for(int i = 0; str[i] == ' '; i++) p++;
        }
        if(!(isNumber(str[p]) || str[p] == '-' || str[p] == '+'))
            return 0;
            
        int sign = 1;
        if(str[p] == '-'){
            sign = -1;
        }
        
        if(str[p] == '-' || str[p] == '+')
            p++;
            
        long long re = 0;
        len = str.length();
        for(int i = p; i &lt; len &amp;&amp; isNumber(str[i]); i++){
            re *= 10;
            re += str[i] - '0';
            
            if(sign &gt; 0 &amp;&amp; re &gt; INT_MAX)
                return INT_MAX;
            if(sign &lt; 0 &amp;&amp; -re &lt; INT_MIN)
                return INT_MIN;
        }
        
        return sign * re;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/09/leetcode-7-reverse-integer/">LeetCode 7. Reverse Integer</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 9, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321</p>
<p>Example2: x = -123, return -321</p>
</blockquote>
<p>问题比较简单, 关键问题在于对于int类型数据表示范围的了解和对溢出的处理.</p>
<p>代码:</p>
<pre><code>class Solution {
public:
    int reverse(int x) {
        long long re = 0;
        int sign = 1;
        if(x &lt; 0){
            sign = -1;
            x = -x;
        }
        while(x &gt; 0){
            re = re * 10 + ( x % 10 );
            x /= 10;
        }
        
        if(re &gt; 0x7fffffff)
            return 0;
        
        return sign * re;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/09/leetcode-6-zigzag-conversion/">LeetCode 6. ZigZag Conversion</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 9, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<pre><code>P   A   H   N
A P L S I I G
Y   I   R
</code></pre>
<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre><code>string convert(string text, int nRows);
</code></pre>
<p><code>convert(&quot;PAYPALISHIRING&quot;, 3)</code> should return <code>&quot;PAHNAPLSIIGYIR&quot;</code>.</p>
</blockquote>
<p>比较简单的字符串处理, 根据给定的要求模拟即可.</p>
<pre><code>class Solution {
public:
    string convert(string s, int numRows) {
        int n = numRows * 2 - 2, len = s.length(), column;
        if(len == 0)
            return string(&quot;&quot;);
        if(numRows == 1)
            return s;
        else
            column = (len / n) * 2 + 2;
        char arr[numRows][column];

        memset(arr, 0, sizeof(arr));
        for(int i = 0; i &lt; len; i++){
            if((i % n) &lt; numRows)
                arr[i % n][i / n * 2] = s[i];
            else
                arr[numRows - (i % n - numRows) - 2][i / n * 2+ 1] = s[i];
        }

        string re;
        for(int i = 0; i &lt; numRows; i++){
            for(int j = 0; j &lt; column; j++)
                if(arr[i][j] != 0)
                    re.push_back(arr[i][j]);
        }

        return re;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/09/leetcode-5-longest-palindromic-substring/">LeetCode 5. Longest Palindromic Substring</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 9, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
</blockquote>
<p>要求找出一个字符串中出现的最长的回文子串. 我自己没有想出什么特别好的办法, 只能用比较暴力的手段来通过. 主要思想就是遍历每一个字符, 对这个字符向两边延伸, 直到不符合回文的定义, 记录下最大值.</p>
<p>代码:</p>
<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length(), longestLen = 0, longestBegin;
        for(int i = 0; i &lt; len; i++){
            bool oddInvalidFlag = false, evenInvalidFlag = false;
            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; len; j++){
                if(s[i - j] != s[i + j]) oddInvalidFlag = true;
                if(s[i - j] != s[i + j + 1]) evenInvalidFlag = true;
                if(oddInvalidFlag &amp;&amp; evenInvalidFlag)
                    break;
                if(!oddInvalidFlag &amp;&amp; s[i - j] == s[i + j] &amp;&amp; (j &lt;&lt; 1) + 1 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 1;
                    longestBegin = i - j;
                }
                if(!evenInvalidFlag &amp;&amp; s[i - j] == s[i + j + 1] &amp;&amp; (j &lt;&lt; 1) + 2 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 2;
                    longestBegin = i - j;
                }
            }
            int j = len - i - 1;
            if(!oddInvalidFlag &amp;&amp; i &gt;= j &amp;&amp; s[i - j] == s[i + j] &amp;&amp; (j &lt;&lt; 1) + 1 &gt; longestLen){
                longestLen = (j &lt;&lt; 1) + 1;
                longestBegin = i - j;
            }
            
        }
        
        return s.substr(longestBegin, longestLen);
    }
};
</code></pre>
<p>以上代码对每一个字符使用了一个循环, 运行时间120ms左右. 但是如果把子串长度为奇数和偶数分开来的话, 速度反而会变快, 我想应该是特定测试数据使总得指令数变少了.</p>
<p>另一个版本:</p>
<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length(), longestLen = 0, longestBegin;
        for(int i = 0; i &lt; len; i++){
            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j &lt; len; j++){
                if(s[i - j] != s[i + j])
                    break;
                if((j &lt;&lt; 1) + 1 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 1;
                    longestBegin = i - j;
                }
            }
            
            for(int j = 0; i - j &gt;= 0 &amp;&amp; i + j + 1 &lt; len; j++){
                if(s[i - j] != s[i + j + 1])
                    break;
                if((j &lt;&lt; 1) + 2 &gt; longestLen){
                    longestLen = (j &lt;&lt; 1) + 2;
                    longestBegin = i - j;
                }
            }
        }
        
        return s.substr(longestBegin, longestLen);
    }
};
</code></pre>
<p><strong>一个优化小Trick</strong></p>
<p>在最外层循环中将循环条件<code>i &lt; len</code>变为<code>i &lt; len - longestLen / 2</code>, Runtime可缩短近半.</p>
<p><strong>更优解</strong></p>
<p>根据这个帖子的方法<a href="https://discuss.leetcode.com/topic/49578/directly-reaching-the-best-solution-4ms-in-c-quite-simple" target="_blank" rel="noopener">https://discuss.leetcode.com/topic/49578/directly-reaching-the-best-solution-4ms-in-c-quite-simple</a>, 运行时间成功缩短到4ms.</p>
<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.length(), longestLen = 0, longestBegin = 0;
        int i = 0;
        while(i &lt; len - longestLen / 2){
            int r = i, l = i;
            for(; r &lt; len - 1 &amp;&amp; s[r] == s[r + 1]; r++);
            i = r + 1;
            for(; l &gt;= 0 &amp;&amp; r &lt; len &amp;&amp; s[l] == s[r]; l--, r++);
            int curLen = r - l - 1;
            if(curLen &gt; longestLen) longestLen = curLen, longestBegin = l + 1;
        }
        
        return s.substr(longestBegin, longestLen);
    }
};
</code></pre>
<p>说明: 判断回文子串的方法不变, 都是向两边延伸, 关键在于回文串中心的选择, <code>for(; r &lt; len - 1 &amp;&amp; s[r] == s[r + 1]; r++);</code>跳过了连续相同的字符, 这是因为连续的相同字符必然是回文串, 可以直接从这样的回文串开始向两边延伸.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/08/leetcode-4-median-of-two-sorted-arrays/">LeetCode 4. Median of Two Sorted Arrays</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目:</p>
<blockquote>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
</blockquote>
<blockquote>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
</blockquote>
<blockquote>
<p>Example 1:</p>
</blockquote>
<blockquote>
<pre><code>nums1 = [1, 3]
nums2 = [2]
</code></pre>
</blockquote>
<blockquote>
<pre><code>The median is 2.0
</code></pre>
</blockquote>
<blockquote>
<p>Example 2:</p>
</blockquote>
<blockquote>
<pre><code>nums1 = [1, 2]
nums2 = [3, 4]
</code></pre>
</blockquote>
<blockquote>
<pre><code>The median is (2 + 3)/2 = 2.5
</code></pre>
</blockquote>
<p>最直接方法, 合并为一个数组后进行排序, 运行时间56ms:</p>
<pre><code>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        for(int i = 0 ; i &lt; nums2.size(); i++)
            nums1.push_back(nums2[i]);
        
        int n = nums1.size();
        partial_sort(nums1.begin(), nums1.end(), nums1.end());
        if(n % 2 == 0)
            return ((double)nums1[n / 2] + (double)nums1[n / 2 - 1]) / 2;
        else
            return (double)nums1[n / 2];
        
    }
};
</code></pre>
<p>另一种方法是利用两个数组都是排好序的这一属性, 将两个数组看作堆, 每次pop出两个数组顶端较小的值, 直到有一半的数被pop出去, 剩下的两个顶端值就可以求得中间值.</p>
<p>运行速度稍有提升:</p>
<pre><code>class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int numTotal = nums1.size() + nums2.size();
        int n = numTotal / 2;
        int p1 = 0, p2 = 0;
        if(numTotal % 2){
            while(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size() &amp;&amp; p1 + p2 &lt; n){
                if(nums1[p1] &lt; nums2[p2]) p1++;
                else p2++;
            }
            if(p1 + p2 &lt; n){
                if(p1 == nums1.size()){
                    while(p1 + p2 &lt; n) p2++;
                }
                if(p2 == nums2.size()){
                    while(p1 + p2 &lt; n) p1++;
                }
            }
            if(p1 == nums1.size()) return (double)nums2[p2];
            else if(p2 == nums2.size()) return (double)nums1[p1];
            else return (double)min(nums1[p1], nums2[p2]);
        }
        else{
            while(p1 &lt; nums1.size() &amp;&amp; p2 &lt; nums2.size() &amp;&amp; p1 + p2 &lt; n - 1){
                if(nums1[p1] &lt; nums2[p2]) p1++;
                else p2++;
            }
            if(p1 + p2 &lt; n - 1){
                if(p1 == nums1.size()){
                    while(p1 + p2 &lt; n - 1) p2++;
                }
                if(p2 == nums2.size()){
                    while(p1 + p2 &lt; n - 1) p1++;
                }
            }
            if(p1 == nums1.size()) return (double)((nums2[p2] + nums2[p2 + 1]) / 2.0);
            else if(p2 == nums2.size()) return (double)((nums1[p1] + nums1[p1 + 1]) / 2.0);
            else{
                int t1, t2;
                if(nums1[p1] &lt; nums2[p2]) t1 = nums1[p1++];
                else t1 = nums2[p2++];
                if(p1 == nums1.size()){
                    t2 = nums2[p2++];
                }
                else if(p2 == nums2.size()){
                    t2 = nums1[p1++];
                }
                else{
                    if(nums1[p1] &lt; nums2[p2]) t2 = nums1[p1++];
                    else t2 = nums2[p2++];
                }
                return (double)((t1 + t2) / 2.0);
            }
        }
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/08/leetcode-3-longest-substring-without-repeating-characters/">LeetCode 3. Longest Substring Without Repeating Characters</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目:</p>
<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters.</p>
</blockquote>
<blockquote>
<p>Examples:</p>
</blockquote>
<blockquote>
<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>
</blockquote>
<blockquote>
<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>
</blockquote>
<blockquote>
<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
</blockquote>
<p>基本思路是遍历一遍字符串, 每访问到一个新字符时, 先检查有没有出现过(而一个字符有没有出现过用一个用字符的ASCII码作为索引的数组保存). 如果没有出现过(用-1表示)就记录下这个第一次出现的下标; 如果出现过, 就把子串的起始位置变为上次出现位置+1, 并把上次出现位置之前的字符设置为-1. 每次循环记录找到的最长长度.</p>
<p>代码:</p>
<pre><code>class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int charHash[128];
        for(int i = 0; i &lt; 128; i++)
            charHash[i] = -1;
            
        int p1 = 0, p2 = 0, maxLength = 0;
        for(; p2 &lt; s.length(); p2++){
            if(charHash[s[p2]] == -1)
                charHash[s[p2]] = p2;
            else{
                int t = charHash[s[p2]] + 1;
                for(; p1 &lt; t; p1++)
                    charHash[s[p2]] = -1;
                charHash[s[p2]] = p2;
            }
            
            if(p2 - p1 + 1&gt; maxLength)
                maxLength = p2 - p1 + 1;
        }
        
        return maxLength;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/08/leetcode-372-super-pow/">LeetCode 372. Super Pow</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
</blockquote>
<blockquote>
<p>Example1:</p>
</blockquote>
<blockquote>
<pre><code>a = 2
b = [3]
</code></pre>
</blockquote>
<blockquote>
<pre><code>Result: 8
</code></pre>
<p>Example2:</p>
</blockquote>
<blockquote>
<pre><code>a = 2
b = [1,0]
</code></pre>
</blockquote>
<blockquote>
<pre><code>Result: 1024
</code></pre>
</blockquote>
<p>计算a的b次幂的值, 其中b很大并且用数组表示. 关键在于结果要对于1337取余, 这就意味着在计算过程中不会发生溢出问题. 根据公式:</p>
<pre><code>(a * b) % n = ((a % n) * (b % n)) % n
</code></pre>
<p>以及</p>
<pre><code>a ^ (n + m) = (a ^ n) * (a ^ m)
</code></pre>
<p>用b{i}表示数组b中到下标i为止的数, <code>a ^ b{i} = ((a ^ b{i - 1}) ^ 10) * (a ^ b[i])</code>, 把幂运算替换为乘法运算和循环, 在每一个循环体中都对结果取余. 就可以得到结果. 其中b[i]为0和第一次循环要特别处理.</p>
<p>代码如下, 耗时24ms:</p>
<pre><code>class Solution {
    int MOD = 1337;
public:
    int superPow(int a, vector&lt;int&gt;&amp; b) {
        int ret = 0;
        for(int i = 0; i &lt; b.size(); i++){
            int t = b[i], retPowTen = 1;
            long long powT = 1;
            for(int j = 0; j &lt; 10; j++){
                retPowTen = (retPowTen * ret) % MOD;
            }
            ret = retPowTen;
            if(t == 0){
                powT = 0;
            }
            else{
                for(int j = 0; j &lt; t; j++){
                    powT = (powT * a) % MOD;
                }
            }
            if(powT &amp;&amp; ret)
                ret = (ret * (powT % MOD)) % MOD;
            else if(!ret)
                ret = powT % MOD;
            else
                ret = ret % MOD;
        }
        return ret;
    }
};
</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/08/leetcode-2-add-tow-numbers/">LeetCode 2. Add Tow Numbers</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目:</p>
<blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
</blockquote>
<blockquote>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>
</blockquote>
<blockquote>
<p>Output: 7 -&gt; 0 -&gt; 8</p>
</blockquote>
<p>简单的加法模拟, 代码如下:</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        //如果有一个链表为空,则直接返回另一个
        if(l1 == nullptr)
            return l2;
        if(l2 == nullptr)
            return l1;
            
        ListNode *p1 = l1, *p2 = l2;
        while(p1-&gt;next != nullptr || p2-&gt;next != nullptr){
            //填充较短的数, 高位添加0, 这一步可以用计算后再处理的办法替代
            if(p1-&gt;next == nullptr)
                p1-&gt;next = new ListNode(0);
            if(p2-&gt;next == nullptr)
                p2-&gt;next = new ListNode(0);
            p1 = p1-&gt;next, p2 = p2-&gt;next;
        }
        
        ListNode *head = new ListNode(0), *p = head;
        int jw = 0;//jw保存上一位计算后的进位
        for(p1 = l1, p2 = l2; p1 != nullptr &amp;&amp; p2 != nullptr; p1 = p1-&gt;next, p2 = p2-&gt;next){
            //模拟每一位的加法
            int t = p1-&gt;val + p2-&gt;val + jw;
            jw = (t &gt; 9 ? 1 : 0);
            
            t = t % 10;
            p-&gt;next = new ListNode(t);
            p = p-&gt;next;
        }
        if(jw == 1){
            //最后有进位的处理
            p-&gt;next = new ListNode(1);
        }
        
        return head-&gt;next;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/08/leetcode-1-two-sum/">LeetCode 1. Two Sum</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 8, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>LeetCode的第一题，题目如下：</p>
<blockquote>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
</blockquote>
<blockquote>
<p>You may assume that each input would have exactly one solution.</p>
</blockquote>
<blockquote>
<p><strong>Example:</strong></p>
</blockquote>
<blockquote>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre>
</blockquote>
<p>首先是简单粗暴的使用STL Map的方法. 基本思路是把nums中的数据与其下标建立一个映射关系, 这样就可以在logn的时间里通过数值获得它的下标：</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        map&lt;int, int&gt; a;
        for(int i = 0; i &lt; nums.size(); i++){
            a[nums[i]] = i;
        }
        for(int i = 0; i &lt; nums.size(); i++){
            auto p = a.find(target - nums[i]);
            if(p != a.end() &amp;&amp; p-&gt;second != i){
                vector&lt;int&gt; re = {i, p-&gt;second};
                return re;
            }
        }
        return vector&lt;int&gt;();
    }
};
</code></pre>
<p>以上方法有两个循环, 其中第一个循环遍历了一遍nums,同时对于每个nums中的数据都进行了map的插入/修改操作, 假设nums的数据个数为n, 复杂度约为O(nlogn). 第二个循环中也是遍历了一遍nums, 然后每一遍循环都执行了一次map的find()操作,最好的情况下只需要循环一次,最坏的情况下需要循环n次,因此平均复杂度约为O((n/2)logn), 总的复杂度在O(nlogn)级别.</p>
<p>这段程序运行时间28ms.</p>
<p>但是这个代码使用了STL中的Map容器, 可能有较大的额外开销, 接下来使用排序 + 二分搜索的方法:</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; re;
        vector&lt;int&gt; oldNums = nums;
        sort(nums.begin(), nums.end());
        for(int i = 0; i &lt; nums.size(); i++){
            int t = target - nums[i];
            if(t &lt; nums.front() || t &gt; nums.back()) continue;
            int j = binSearch(nums, t);
            if(j == -1 || j == i) continue;
            else {
                int num1 = nums[i], num2 = nums[j];
                for(int k = 0; k &lt; oldNums.size(); k++){
                    if(oldNums[k] == num1 || oldNums[k] == num2) re.push_back(k);
                    if(re.size() == 2) break;
                }
                return re;
            }
        }
        return re;
    }
    
    int binSearch(vector&lt;int&gt; &amp;nums, int t){
        int l = 0, r = nums.size(), m = (l + r) / 2;
        while(l &lt; r){
            if(nums[m] == t) return m;
            else if(nums[m] &gt; t) r = m;
            else l = m + 1;
            m = (l + r) / 2;
        }
        return -1;
    }
};
</code></pre>
<p>第二个方法的运行时间缩短为12ms.</p>
<p>还有另一种更加简洁的双指针方法:</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; re;
        vector&lt;int&gt; oldNums = nums;
        sort(nums.begin(), nums.end());
        int l = 0, r = nums.size() - 1;
        while(l &lt; r){
            int sum = nums[l] + nums[r];
            if(sum == target){
                for(int i = 0; i &lt; nums.size() &amp;&amp; re.size() &lt; 2; i++){
                    if(oldNums[i] == nums[l] || oldNums[i] == nums[r]) re.push_back(i);
                }
                break;
            }
            else if(sum &gt; target){
                r--;
            }
            else{
                l++;
            }
        }
        return re;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/06/10/%E5%B7%9D%E5%A4%A7%E6%B1%9F%E5%AE%89%E6%A0%A1%E5%8C%BA%E5%AE%BD%E5%B8%A6%E7%A0%B4%E8%A7%A3/">川大江安校区宽带破解</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jun 10, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <!-- toc -->
<h2 id="0-前言">0 前言</h2>
<p>四年大学生活马上就要结束了，想一想这四年在江安的生活还真是相当不错的；不过对于我来说，网络大概是江安学习生活中最烦人的东西了。从我2012年入学开始到现在的2016年，川大江安在宿舍所能使用的网络接入方式有三种：校园网、移动CMCC-EDU和电信宽带。其中校园网虽然免费，这四年来雷打不动的512kbps的带宽，基本是处于看图片都是煎熬的水平；CMCC-EDU我基本没用过，速度大概是4Mbps左右，可惜无线不稳定；剩下的电信宽带虽然非常贵（一个月79元，带宽6Mbps，但是可以抵扣话费，奈何我不用电信手机），但是矮子里面拔将军，是唯一比较好用的了。</p>
<p><strong>但是</strong>，这是建立在电信不限制路由器的基础上的。其实在2012年下半年的时候，电信宽带是不限制路由器的，使用普通的pppoe拨号方式就可以上网了。但是这只是电信认证系统的bug而已（还有另一种阴谋论的说法，就不详细说了。另外江安这个认证系统bug极多，后面我会详细说说），2013年上半年的时候修复了，导致路由器失效，接着电信更新了拨号器（就是本文将要破解的），导致飞扬俱乐部的在线算号器失效（方法是粗暴的禁止Linux版拨号器，至今再没有可用的官方Linux拨号器），当时在学生中算是引起了很大的反弹，可是学校方面不知道出于什么原因一直避而不谈这件事（<s>呵呵，这其中必然有肮脏的**交易</s>），电信抬出什么公安部教育部要求大学生上网一人一号的文件（<s>监控之心不死</s>）来当挡箭牌，这件事后来也不了了之了。但是不能用路由器你让手机iPad怎么上网？许多同学选择通过电脑发射无线信号（其实这也是被拨号器所屏蔽的，不过比较好突破），但是这个方法非常繁琐，要保持电脑一直开机。除了这种方法以外就只能放弃电信宽带了，不过我是一个网速多快都不嫌快，慢一点就无法忍受的人，所以就只能自己动手来破解电信的拨号器了。</p>
<p>在此要特别感谢软件学院的HZY同学，在我破解的过程中提供了很多帮助。</p>
<p><strong>我的宽带帐号是12年就有的，用户名是学号，跟后来的用户名是手机号的不一样，所以不保证对后来的账号有效。</strong></p>
<p>完整代码与原版Mac拨号器程序请移步<a href="https://github.com/xiadong1994/SCU_JiangAn_Dialer" target="_blank" rel="noopener">Github</a>。</p>
<h2 id="1-2-21版mac协同拨号器拨号流程">1 2.21版Mac协同拨号器拨号流程</h2>
<p>我在13年的时候破解的是2.21版的Mac拨号器，Windows版的拨号器的程序逻辑要相对复杂许多，这个版本的算法直到目前（16年6月）都还是可用的。PPPoE的介绍和普通的PPPoE拨号流程可以参考Wikipedia：<a href="https://www.wikiwand.com/zh-cn/PPPoE" target="_blank" rel="noopener">https://www.wikiwand.com/zh-cn/PPPoE</a>和RFC文档：<a href="https://tools.ietf.org/html/rfc2516" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc2516</a>。计算机自带的PPPoE拨号器无法连接电信宽带的原因主要出在电信使用一种“二次验证”的机制，即计算机第一次拨号的时候是必然失败的，同时认证服务器返回一个字符串，拨号器根据这个字符串通过算法生成一个新的用户名，再次进行拨号才能成功。其中第一次拨号的用户名也是通过算法生成的，不过与服务器无关。</p>
<p>通过抓包就可以比较直观的看到拨号器拨号的整个流程，我已经很久没有装过协同拨号器了，在这里只贴一下我的路由器模拟的拨号过程。</p>
<p>这是第一次拨号的过程，可以看到CHAP认证失败并且返回16进制字符串：37f13ef44a72。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: Plugin rp-pppoe.so loaded.</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.notice pppd[2435]: pppd 2.4.5 started by root, uid 0</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: PPP session is 30874</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.warn pppd[2435]: Connected to 00:25:9e:08:b8:3e via interface eth2.2</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.info pppd[2435]: Using interface pppoe-wan</span><br><span class="line">Jan  1 00:34:12 PandoraBox daemon.notice pppd[2435]: Connect: pppoe-wan &lt;--&gt; eth2.2</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: syncppp not active</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: CHAP authentication failed: 37f13ef44a72</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.err pppd[2435]: CHAP authentication failed</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.notice pppd[2435]: Connection terminated.</span><br><span class="line">Jan  1 00:34:15 PandoraBox daemon.info pppd[2435]: Exit.</span><br></pre></td></tr></table></figure>
<p>这是第二次的拨号流程，可以看到认证成功并分配了IP地址等信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: Plugin rp-pppoe.so loaded.</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.notice pppd[2447]: pppd 2.4.5 started by root, uid 0</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: PPP session is 19277</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.warn pppd[2447]: Connected to 00:25:9e:08:b8:3e via interface eth2.2</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.info pppd[2447]: Using interface pppoe-wan</span><br><span class="line">Jan  1 00:34:23 PandoraBox daemon.notice pppd[2447]: Connect: pppoe-wan &lt;--&gt; eth2.2</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.info pppd[2447]: syncppp not active</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.info pppd[2447]: CHAP authentication succeeded: Authentication success,Welcome!</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: CHAP authentication succeeded</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: peer from calling number 00:25:9E:08:B8:3E authorized</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: local  IP address 220.167.43.208</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: remote IP address 220.167.40.1</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: primary   DNS address 61.139.2.69</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice pppd[2447]: secondary DNS address 202.98.96.68</span><br><span class="line">Jan  1 00:34:26 PandoraBox daemon.notice netifd: Interface &#39;wan&#39; is now up</span><br></pre></td></tr></table></figure>
<h2 id="3-关于如何破解">3 关于如何破解</h2>
<p>主要使用IDA作为反汇编工具，最关键的就是阅读反汇编拨号器出来的汇编代码和IDA生成的反编译代码。编写自己的拨号器的使用的是C语言，当然也可以自由选择其他的语言。使用libpcap在程序内进行抓包。我在破解的最后阶段还用了GDB在命令行模式下直接调试官方拨号器，在没有调试信息的情况下跟踪程序运行真是很酸爽。</p>
<p>这个破解程序是差不多三年前写的了，当时接触编程和C语言不到一年，代码写的很烂，但是因为一直能用就没有再做什么改动了。</p>
<h2 id="4-生成第一次拨号的用户名">4 生成第一次拨号的用户名</h2>
<p>这个生成第一次拨号用户名的算法是完全模拟的协同拨号器的工作方式。首先获取系统时间，再和一个特殊字符串、用户名、密码拼接成一个新字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time1=time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">sprintf</span>((<span class="keyword">char</span>*)strTime,<span class="string">"%08x"</span>,time1);</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)first,<span class="string">"%s%s%s%s"</span>,strTime,<span class="string">"m2o=crE54nyNUht["</span>,username,psw);</span><br></pre></td></tr></table></figure>
<p>对该字符串计算MD5值并转换成16进制表示的字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MD5_CTX md5;</span><br><span class="line">MD5Init(&amp;md5);         		</span><br><span class="line">MD5Update(&amp;md5,first,<span class="built_in">strlen</span>((<span class="keyword">char</span>*)first));</span><br><span class="line">MD5Final(&amp;md5,md5Result);</span><br><span class="line"><span class="comment">//把md5转换成字符串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">16</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span>*)pMd5Str,<span class="string">"%02x"</span>,md5Result[j]);</span><br><span class="line">    pMd5Str+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后取该字符串的前19个字符，再与其他字符串一起拼接成最终的用户名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> md5Str19[<span class="number">20</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(md5Str19,md5Str,<span class="number">19</span>);	<span class="built_in">sprintf</span>((<span class="keyword">char</span>*)userName,<span class="string">"%s%s%s%s%s"</span>,strTime,<span class="string">"M"</span>,<span class="string">"2021"</span>,md5Str19,username);</span><br></pre></td></tr></table></figure>
<h2 id="5-进行拨号">5 进行拨号</h2>
<p>获得了第一个用户名之后就可以进行拨号了。这个拨号的方法是根据不同的平台而不同，我在Windows和Linux系统（主要是路由器运行的OpenWRT）上都移植过这个程序，可以说唯一需要修改的地方就是这里了。我在这里放一下我在路由器上运行的版本的拨号函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PPPoeDial</span><span class="params">(<span class="keyword">char</span> *user,<span class="keyword">char</span> *pwd,<span class="keyword">char</span> *name,<span class="keyword">char</span> *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> pppoe_cmd[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> ifname[<span class="number">40</span>]=<span class="string">"pppoe-"</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(pppoe_cmd,<span class="string">"/usr/sbin/pppd nodetach ipparam %s ifname %s nodefaultroute usepeerdns persist maxfail 1 user %s password %s ip-up-script /lib/netifd/ppp-up ipv6-up-script /lib/netifd/ppp-up ip-down-script /lib/netifd/ppp-down ipv6-down-script /lib/netifd/ppp-down mtu 1492 mru 1492 plugin rp-pppoe.so nic-%s &amp;"</span>,\</span><br><span class="line">    name,<span class="built_in">strcat</span>(ifname,name),user,pwd,device);</span><br><span class="line">    system(pppoe_cmd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"拨号中。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的pppoe_cmd的内容要根据对应的平台调整。<strong>Windows平台本身就提供了拨号函数，不需要运行pppd之类的命令了。</strong></p>
<h2 id="6-获取服务返回的参数">6 获取服务返回的参数</h2>
<p>在我的程序中是通过使用libpcap库进行抓包来获取服务器返回的字符串的。libpcap库相关的信息请访问官网<a href="http://www.tcpdump.org" target="_blank" rel="noopener">http://www.tcpdump.org</a>。对每个数据包的回调函数是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(valid &amp;&amp; pkt_data[<span class="number">22</span>]==<span class="number">0x04</span>&amp;&amp;pkt_data[<span class="number">23</span>]==<span class="number">0x01</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pcap_breakloop(adhandle);</span><br><span class="line">        valid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> seed[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        		<span class="built_in">sprintf</span>(&amp;seed[i],<span class="string">"%c"</span>,pkt_data[<span class="number">30</span>+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"seed:%s\n"</span>,seed);</span><br><span class="line">        <span class="keyword">int</span> time2=((<span class="keyword">unsigned</span> <span class="keyword">int</span>)rand())&lt;&lt;<span class="number">16</span>|rand();</span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        getSecondUserName(result,seed,g_userName,g_pwd,time1,time2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,result);</span><br><span class="line">        sleep(<span class="number">8</span>);</span><br><span class="line">        PPPoeDial(result,g_pwd,wan,d-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>pkt_data[22]==0x04&amp;&amp;pkt_data[23]==0x01</code>是表示这个数据包是服务器返回的认证失败的数据包，从中取得字符串<code>seed</code>，然后产生一个随机数time2，作为产生第二个用户名的参数。sleep(8)的目的是等待第一次拨号的进程完全退出以免造成冲突。
​</p>
<h2 id="7-生成第二次的用户名">7 生成第二次的用户名</h2>
<p>生成第二次用户名的函数比较复杂，具体还是参见代码中的实现吧。主要思路仍然是对字符串进行处理后计算MD5值再进行拼接。</p>
<h2 id="8-运行平台">8 运行平台</h2>
<p>在破解出这个算法后，我写过Windows和OpenWRT版本的拨号器，我相信大多数同学都是想使用路由器的，使用路由器很简单，只需要一个刷了OpenWRT的路由器就可以了，下载相应的工具链之后进行交叉编译，把得到的可执行文件上传到路由器上，再添加启动脚本就可以实现开机自动连接宽带了。</p>
<h2 id="9-后记与扯扯淡">9 后记与扯扯淡</h2>
<p>江安校区的电信宽带真的是相当奇葩，贵而难用，而且BUG多多，单单我知道的就有：把用户名最后几位去掉就可以使用无上限的带宽（取决于你寝室的出口物理带宽）；同样是去掉几位就可以进行无限制的多拨（带宽叠加）；绑定的手机号注销之后宽带帐号还在等等。靠着前两个bug我还是享受了将近两年的50M以上宽带的，虽然到现在这些bug已经修复了，但是说不定还是有其他bug，这就交给学弟学妹们来开发啦。</p>
<p>有了OpenWRT路由器之后可玩的东西就变得挺多了，完全可以当一个24h运行小服务器来用。比如以前我还在用多拨叠加宽带的时候因为有一定概率拨号失败（挺低的），所以就写了一个shell脚本，拨号完成后发邮件通知我有没有没连上的连接。或者写一个桥接CMCC信号并且自动登陆的脚本等等。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/39/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/41/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Shell32-Natsu" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
