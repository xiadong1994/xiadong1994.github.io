<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/34/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/34/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/03/leetcode-56-merge-intervals/">LeetCode 56. Merge Intervals</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 3, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,</p>
<p>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,</p>
<p>return <code>[1,6],[8,10],[15,18]</code>.</p>
</blockquote>
<p>合并(闭)区间, 区间以对象的形式给出. 首先将输入的区间数组按照<code>start</code>从小到大排序, 然后先取第一个元素放入结果集中, 从第二个元素开始遍历. 取当前区间为<code>cur</code>, 结果集中的最后一个元素为<code>pre</code>. 如果<code>cur.start &gt; pre.end</code>, 说明<code>cur</code>与<code>pre</code>并无交集, 由于有序, 所以<code>cur</code>以后的区间与<code>pre</code>也都没有交集, 所以可以将<code>cur</code>放入结果集中. 如果<code>cur.start &lt;= pre.end</code>, 说明有交集, 由于必然存在<code>cur.start &gt;= pre.start</code>, 所以新区间的<code>start</code>等于<code>pre.start</code>, 只要考虑<code>cur.end</code>与<code>pre.end</code>的大小关系, 如果<code>cur.end &lt;= pre.end</code>, 那么新区间与<code>pre</code>相同; 如果<code>cur.end &gt; pre.end</code>那么要把<code>pre</code>也就是结果集的最后一个区间的<code>end</code>修改为<code>cur.end</code>.</p>
<pre><code>/**
* Definition for an interval.
* struct Interval {
*     int start;
*     int end;
*     Interval() : start(0), end(0) {}
*     Interval(int s, int e) : start(s), end(e) {}
* };
*/
class Solution {
public:
    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) {
        vector&lt;Interval&gt; ret;
        if(intervals.empty()) return ret;
        sort(intervals.begin(), intervals.end(), [=](Interval &amp;a, Interval &amp;b){
            return a.start &lt; b.start;
        });
        ret.push_back(intervals[0]);
        for(int i = 1; i &lt; intervals.size(); i++){
            Interval cur = intervals[i], pre = ret.back();
            if(cur.start &gt; pre.end){
                ret.push_back(cur);
            }
            else{
                if(cur.end &gt; pre.end){
                    ret.back().end = cur.end;
                }
            }
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/03/leetcode-55-jump-game/">LeetCode 55. Jump Game</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 3, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:</p>
<p>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
</blockquote>
<p>数组中的每个元素表示从当前下标可以向前跳的距离, 返回能不能到达最后一个下标. 从第一个元素开始记录从当前元素能到达的最远的下标值, 对之后的每个元素更新这个值, 如果该值小于当前下标则说明该下标无法到达.</p>
<pre><code>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int farthest = nums[0], i;
        for(i = 1; i &lt; nums.size() &amp;&amp; farthest &gt;= i; i++){
            farthest = max(farthest, nums[i] + i);
        }
        if(farthest &gt;= nums.size() - 1)
            return true;
        else
            return false;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/02/leetcode-54-spiral-matrix/">LeetCode 54. Spiral Matrix</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 2, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,
Given the following matrix:</p>
<pre><code>[
  [ 1, 2, 3 ],
  [ 4, 5, 6 ],
  [ 7, 8, 9 ]
]
</code></pre>
<p>You should return <code>[1,2,3,6,9,8,7,4,5]</code>.</p>
</blockquote>
<p>螺旋形输出一个矩阵, 我的方法就是螺旋形地遍历这个矩阵. 用一个变量来表示方向, 到达矩阵边缘的时候就更改方向.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt; re;
        if (matrix.size() == 0 || matrix[0].size() == 0)
            return re;
        int m = matrix.size(), n = matrix[0].size(), num = m * n;
        vector&lt;int&gt; row(n, 0);
        vector&lt;vector&lt;int&gt;&gt; visited(m, row);
        int direction = 0;// 0 =&gt; right, 1 =&gt; down, 2 =&gt; left, 3 =&gt; up
        int posRow = 0, posCol = 0, cnt = 0;
        while (cnt &lt; num) {
            int nextPosRow, nextPosCol;
            if(!visited[posRow][posCol]){
                re.push_back(matrix[posRow][posCol]);
                visited[posRow][posCol] = 1;
                cnt++;
            }
            bool nextPosValid = true;
            switch (direction) {
            case 0:
                nextPosRow = posRow;
                nextPosCol = posCol + 1;
                if (nextPosCol &gt;= n || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 1:
                nextPosRow = posRow + 1;
                nextPosCol = posCol;
                if (nextPosRow &gt;= m || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 2:
                nextPosRow = posRow;
                nextPosCol = posCol - 1;
                if (nextPosCol &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            case 3:
                nextPosRow = posRow - 1;
                nextPosCol = posCol;
                if (nextPosRow &lt; 0 || visited[nextPosRow][nextPosCol] == 1) {
                    nextPosValid = false;
                }
                break;
            }
            if(nextPosValid){
                posRow = nextPosRow;
                posCol = nextPosCol;
            }
            else{
                direction = (direction + 1) % 4;
            }
        }
        return re;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/02/leetcode-53-maximum-subarray/">LeetCode 53. Maximum Subarray</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 2, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],
the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
</blockquote>
<p>题目要求找出最大的连续子序列的和, 首先采用一种分治法. 对于一个数组, 把它中中间分成两半, 和最大的连续子序列可能出现在左半边, 可能出现在右半边, 也有可能出现跨越左右的情况. 对于在左半边或右半边的情况, 可以使用递归缩小问题, 对于跨越左右的情况, 可以使用线性算法来获得结果. 最后返回三个值中的最大值.</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        return maxSub(nums, 0, nums.size());
    }

    int maxSub(vector&lt;int&gt;&amp; nums, int left, int right) {
        if (right - left == 1) {
            return nums[left];
        }
        int leftSum, rightSum, mid = (left + right) / 2;
        leftSum = maxSub(nums, left, mid);
        rightSum = maxSub(nums, mid, right);

        int midLeftSum = 0, midLeftMaxSum = INT_MIN, midRightSum = 0, midRightMaxSum = INT_MIN;
        for (int i = mid - 1; i &gt;= left; i--) {
            midLeftSum += nums[i];
            if (midLeftSum &gt; midLeftMaxSum) midLeftMaxSum = midLeftSum;
        }
        for (int i = mid; i &lt; right; i++) {
            midRightSum += nums[i];
            if (midRightSum &gt; midRightMaxSum) midRightMaxSum = midRightSum;
        }
        int midSum = midRightMaxSum + midLeftMaxSum;

        return max(midSum, max(leftSum, rightSum));
    }
};
</code></pre>
<p>还可以使用动态规划法. 使用<code>dp[i]</code>来表示包含<code>nums[i]</code>的和最大的连续子串的和. 如果<code>dp[i-1]</code>是大于0的, 那么就可以加上<code>dp[i-1]</code>, 因为<code>nums[i]</code>是必须有的. 用另一种方式来说, 这个题目的主要问题在于和最大的连续子串中可能出现负数, 要考虑的是负数及负数之前的子串要不要加到当前子串中来, 而这个判断就是看以该负数结尾的连续子串的和是否大于0, 如果小于0则不能加进来, 大于0则可以.</p>
<pre><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; dp(nums.size(), 0);
        int ret = nums[0];
        dp[0] = nums[0];
        for(int i = 1; i &lt; nums.size(); i++){
            dp[i] = dp[i - 1] &gt; 0 ? dp[i - 1] + nums[i] : nums[i];
            if(ret &lt; dp[i])
                ret = dp[i];
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/01/leetcode-52-n-queens-ii/">LeetCode 52. N-Queens II</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 1, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
</blockquote>
<p>与上一题<a href="http://xiadong.info/2016/08/leetcode-51-n-queens/" target="_blank" rel="noopener">51. N-Queens</a>基本类似, 但是要求返回共有多少个解, 对上一个程序稍加改动即可. <s>当然, 最投机取巧的做法是算出n=1到9的结果然后直接返回</s>.</p>
<pre><code>class Solution {
public:
    int totalNQueens(int n) {
        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));
        int re = 0;
        NQueensRow(n, board, 0, re);
        return re;
    }
    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, int &amp;re) {
        if (row == n) {
            re++;
            return;
        }
        for (int i = 0; i &lt; n; i++) {
            if (validPos(board, row, i)) {
                board[row][i] = 1;
                NQueensRow(n, board, row + 1, re);
                board[row][i] = 0;
            }
        }
    }

    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {
        int n = board.size();
        for (int i = 0; i &lt; n; i++) {
            if (board[x][i] &amp;&amp; i != y)
                return false;
            else if (board[i][y] &amp;&amp; i != x)
                return false;
        }

        int xt, yt;
        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {
            if (board[xt][yt])
                return false;
        }
        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {
            if (board[xt][yt])
                return false;
        }

        return true;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/01/leetcode-51-n-queens/">LeetCode 51. N-Queens</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 1, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
<p><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""></p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,
There exist two distinct solutions to the 4-queens puzzle:</p>
<pre><code>[
    [&quot;.Q..&quot;,  // Solution 1
    &quot;...Q&quot;,
    &quot;Q...&quot;,
    &quot;..Q.&quot;],

    [&quot;..Q.&quot;,  // Solution 2
    &quot;Q...&quot;,
    &quot;...Q&quot;,
    &quot;.Q..&quot;]
]
</code></pre>
</blockquote>
<p>N皇后问题, 采用递归+回溯的方法, 依次穷举每一种情况.</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        vector&lt;vector&lt;int&gt;&gt; board(n, vector&lt;int&gt;(n, 0));
        vector&lt;vector&lt;string&gt;&gt; re;
        NQueensRow(n, board, 0, re);
        return re;
    }

    void NQueensRow(int n, vector&lt;vector&lt;int&gt;&gt; &amp;board, int row, vector&lt;vector&lt;string&gt;&gt; &amp;re) {
        if (row == n) {
            reItem(board, re);
            return;
        }
        for (int i = 0; i &lt; n; i++) {
            if (validPos(board, row, i)) {
                board[row][i] = 1;
                NQueensRow(n, board, row + 1, re);
                board[row][i] = 0;
            }
        }
    }

    bool validPos(vector&lt;vector&lt;int&gt;&gt; &amp;board, int x, int y) {
        int n = board.size();
        for (int i = 0; i &lt; n; i++) {
            if (board[x][i] &amp;&amp; i != y)
                return false;
            else if (board[i][y] &amp;&amp; i != x)
                return false;
        }

        int xt, yt;
        for (xt = x - 1, yt = y - 1; xt &gt;= 0 &amp;&amp; yt &gt;= 0; xt--, yt--){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y + 1; xt &lt; n &amp;&amp; yt &lt; n; xt++, yt++) {
            if (board[xt][yt])
                return false;
        }
        for (xt = x - 1, yt = y + 1; xt &gt;= 0 &amp;&amp; yt &lt; n; xt--, yt++){
            if (board[xt][yt])
                return false;
        }
        for (xt = x + 1, yt = y - 1; xt &lt; n &amp;&amp; yt &gt;= 0; xt++, yt--) {
            if (board[xt][yt])
                return false;
        }

        return true;
    }

    void reItem(vector&lt;vector&lt;int&gt;&gt; &amp;board, vector&lt;vector&lt;string&gt;&gt; &amp;ret) {
        int n = board.size();
        vector&lt;string&gt; re(n, string(n, '.'));
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; n; j++) {
                if(board[i][j]) re[i][j] = 'Q';
            }
        }
        ret.push_back(re);
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/08/01/leetcode-378-kth-smallest-element-in-a-sorted-matrix/">LeetCode 378. Kth Smallest Element in a Sorted Matrix</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Aug 1, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>Example:</p>
<pre><code>matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
</code></pre>
<p>Note:</p>
<p>You may assume k is always valid, 1 ≤ k ≤ n<sup>2</sup>.</p>
</blockquote>
<p>首先的想法是每次从n行中取最前端的n个值中的最小值, 然后这个值从该行删除, 重复k次. 时间复杂度O(nk). 实际运行时间280ms.</p>
<pre><code>class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        vector&lt;int&gt; matrixPos(n, 0);
        int ret;
        for(int i = 0; i &lt; k; i++){
            int minNum = INT_MAX, minPos = 0;
            for(int j = 0; j &lt; n; j++){
                if(matrixPos[j] == n) continue;
                if(matrix[j][matrixPos[j]] &lt; minNum){
                    minNum = matrix[j][matrixPos[j]];
                    minPos = j;
                }
            }
            matrixPos[minPos]++;
            ret = minNum;
        }
        return ret;
    }
};
</code></pre>
<p>使用二分搜索, 不过搜算范围是<code>int</code>类型的整个表示范围, 为避免溢出, 使用long long来保存左右边界. Runtime: 80ms.</p>
<pre><code>class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        long long l = INT_MIN, r = INT_MAX, mid;
        while(l &lt; r){
            mid = (l + r) &gt;&gt; 1;
            int kth = 0;
            for(int i = 0; i &lt; n; i++){
                for(int j = 0; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++){
                    kth++;
                }
            }
            if(kth &lt; k) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
</code></pre>
<p>另一种使用堆的方法, 先按从上往下, 从左往右的顺序将k个元素放入堆中. 对于剩下的元素, 每一行从头开始与堆顶比较, 如果小于堆顶, 就把它放入堆中, 把原堆顶弹出. 改行中出现&gt;=堆顶的元素时即可停止对这一行的处理. 运行时间112ms.</p>
<pre><code>class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int n = matrix.size();
        priority_queue&lt;int&gt; heap;
        for(int i = 0; i &lt; n; i++){
            if(heap.size() &lt; k){
                int j;
                for(j = 0; j &lt; n &amp;&amp; heap.size() &lt; k; j++){
                    heap.push(matrix[i][j]);
                }
                for(; j &lt; n &amp;&amp; heap.top() &gt; matrix[i][j]; j++){
                    heap.pop();
                    heap.push(matrix[i][j]);
                }
            }
            else{
                for(int j = 0; j &lt; n &amp;&amp; heap.top() &gt; matrix[i][j]; j++){
                    heap.pop();
                    heap.push(matrix[i][j]);
                }
            }
        }
        return heap.top();
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/31/leetcode-50-powx-n/">LeetCode 50. Pow(x, n)</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 31, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Implement pow(x, n).</p>
</blockquote>
<p>题目要求实现pow函数. 首先n若小于0, 则可以先把x取倒数, 然后n取相反数, 从而变为n大于0的情况(但是由于int表示范围的问题, 所以新的n应该使用long long来存储), 所以只要考虑n大于0的情况. x<sup>n</sup> = (x<sup>2</sup>)<sup>n/2</sup>(n为偶数); x<sup>n</sup> = x*(x<sup>2</sup>)<sup>(n - 1)/2</sup>(n为奇数), 所以循环次数可以降低至logn次.</p>
<pre><code>class Solution {
public:
    double myPow(double x, int n) {
        long long nn = n;
        double re = 1;
        if(nn == 0) return 1;
        if(nn &lt; 0){
            x = 1 / x;
            nn = -nn;
        }
        while(nn &gt; 1){
            if(nn % 2 == 0){
                x *= x;
                nn = nn &gt;&gt; 1;
            }
            else{
                re *= x;
                nn -= 1;
            }
        }
        return re * x;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/31/leetcode-49-group-anagrams/">LeetCode 49. Group Anagrams</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 31, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],
Return:</p>
<pre><code>[
  [&quot;ate&quot;, &quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</code></pre>
</blockquote>
<p>anagram的意思是&quot;颠倒字母而成的词句&quot;, 也就是要把由相同字母组成的但顺序不同的字符串放到一起. 使用hash表, 对每个字符串中的字符排序后得到的新字符串作为hash表的key, value则是对应的原字符串集合.</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string, vector&lt;string&gt;&gt; m;
        vector&lt;vector&lt;string&gt;&gt; ret;
        for(int i = 0; i &lt; strs.size(); i++){
            string s = strs[i];
            sort(s.begin(), s.end());
            if(m.count(s)){
                m[s].push_back(strs[i]);
            }
            else{
                m[s] = vector&lt;string&gt;(1, strs[i]);
            }
        }
        ret.resize(m.size()); //预先扩展ret的大小, 避免在循环中push_back频繁分配新的内存空间
        int cnt = 0;
        for(auto i = m.begin(); i != m.end(); i++){
            ret[cnt++] = (i-&gt;second);
        }
        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/31/leetcode-48-rotate-image/">LeetCode 48. Rotate Image</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 31, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:
Could you do this in-place?</p>
</blockquote>
<p>题目要求将一个n*n数组顺时针旋转90度, 并且最好不使用额外空间. 所以用对角线将矩阵分为四个区域, 对于每个区域内的每个元素依次放入上一个区域的值.</p>
<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        for(int i = 0; i &lt; n / 2; i++){
            for(int j = i; j &lt; n - 1 - i; j++){
                int swap_t = matrix[i][j];
                matrix[i][j] = matrix[n - 1 - j][i];
                matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
                matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
                matrix[j][n - 1 - i] = swap_t;
            }
        }
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/33/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/35/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Shell32-Natsu" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
