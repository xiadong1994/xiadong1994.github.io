<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />









  <link rel="alternate" href="/atom.xml" title="Shell32">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.3.x" />



<link rel="canonical" href="http://blog.xiadong.info/page/37/"/>


<meta property="og:type" content="website">
<meta property="og:title" content="Shell32">
<meta property="og:url" content="http://blog.xiadong.info/page/37/index.html">
<meta property="og:site_name" content="Shell32">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shell32">
<meta name="twitter:card" content="summary">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.3.x" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





<script>
  var CONFIG = {
    search: false,
    searchPath: "/search.xml",
    fancybox: true,
    toc: true,
  }
</script>




  

  <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-97442160-1', 'auto');
        ga('send', 'pageview');
  </script>




<script src="https://use.typekit.net/tqr0ojg.js"></script>
<script>try{Typekit.load({ async: true });}catch(e){}</script>

    <title> Shell32 </title>
  <meta name="generator" content="Hexo 4.2.1"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Shell32</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Archives
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
      <a href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
        <li class="mobile-menu-item">
          
          
            Search
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Shell32</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Archives
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="https://cse.google.com/cse/publicurl?cx=007205548471419455342:wndla_xl_3e" target="_blank" rel="noopener">
            
            
              Search
            
          </a>
        </li>
      
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/23/leetcode-30-substring-with-concatenation-of-all-words/">LeetCode 30. Substring with Concatenation of All Words</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 23, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:</p>
<p>s: “barfoothefoobarman”</p>
<p>words: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].</p>
<p>(order does not matter).</p>
</blockquote>
<p>首先使用暴力法, 将words中的词放入一个哈希表中, 这样可以在常数时间内找到它. 然后用一个双重循环来遍历字符串s.</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ret;
        int wordsLen = words.size();
        if(wordsLen == 0)
            return ret;
        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;
        
        unordered_map&lt;string, int&gt; wordExistOrig;
        
        for(int i = 0; i &lt; wordsLen; i++){
            if(wordExistOrig.count(words[i])){
                wordExistOrig[words[i]]++;
            }
            else{
                wordExistOrig[words[i]] = 1;
            }
        }
        
        for(int i = 0; i &lt;= sLen - totalLen; i++){
            unordered_map&lt;string, int&gt; wordExist = wordExistOrig;
            bool valid = true;
            for(int j = i; j &lt; totalLen + i; j += wordLen){
                string str = s.substr(j, wordLen);
                if(wordExist.count(str) == 0) {
                    valid = false;
                    break;
                }
                else{
                    wordExist[str]--;
                    if(wordExist[str] &lt; 0){
                        valid = false;
                        break;
                    }
                }
            }
            if(valid) ret.push_back(i);
        }
        
        return ret;
    }
};
</code></pre>
<p>还可以使用一种&quot;滑动窗口&quot;方法, 或者是双指针方法, 思路参考这里: <a href="http://www.2cto.com/kf/201406/311648.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201406/311648.html</a>. 举例来说比如题目中的例子: <code>&quot;barfoothefoobarman&quot;</code>和数组<code>[&quot;foo&quot;, &quot;bar&quot;]</code>, 首先窗口长度为0, 起始位置为0, 窗口长度和起始位置都是以单词长度的整数倍变化的, 这里是3, 首先把第一个单词放进窗口(用<code>{}</code>来表示窗口): <code>{bar}foothefoobarman</code>, 由于<code>foo</code>和<code>bar</code>每个都只出现一次, 所以把<code>bar</code>的剩余次数(这个次数保存在hash表中)减1变为0, 接下来把下一个单词放入窗口: <code>{barfoo}thefoobarman</code>, 同样把<code>foo</code>的次数减1变为0, 这时窗口中已经有两个单词, 与words数组的大小相同, 就可以把当前的窗口起始位置放入结果集中. 接下来是单词<code>the</code>, 这个单词在words数组中没有, 所以窗口可以直接跳过它, 将窗口起始位置越过的<code>bar</code>和<code>foo</code>的允许出现次数加1, 此时窗口位置位于<code>barfoothe{}foobarman</code>, 然后重复这个步骤. 为了不忽略类似<code>abarfoo</code>这种字符串中的结果, 所以要将窗口起始位置从0到单词长度3遍历一次.</p>
<p>代码如下, 运行时间36ms:</p>
<pre><code>class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; ret;
        int wordsLen = words.size();
        if (wordsLen == 0)
            return ret;
        int wordLen = words[0].length(), sLen = s.length(), totalLen = wordsLen * wordLen;

        unordered_map&lt;string, int&gt; wordExist;

        for (int i = 0; i &lt; wordsLen; i++) {
            if (wordExist.count(words[i])) {
                wordExist[words[i]]++;
            }
            else {
                wordExist[words[i]] = 1;
            }
        }
        for (int i = 0; i &lt; wordLen; i++) {
            int slideLeft = i, j = i, wordFound = 0;

            while (slideLeft &lt;= sLen - totalLen &amp;&amp; j &lt; sLen) {
                string str = s.substr(j, wordLen);
                if (wordExist.count(str) == 0) {
                    //下一个单词不再words中时将窗口初始位置移到当前之后的位置
                    j += wordLen;
                    for (; slideLeft &lt; j; slideLeft += wordLen) {
                        string toDropStr = s.substr(slideLeft, wordLen);
                        if(wordExist.count(toDropStr))wordExist[toDropStr]++;
                    }
                    //slideLeft = j;
                    wordFound = 0;
                    continue;
                }
                if (wordFound == wordsLen) {
                    //当窗口满的时候丢弃最前端的字符串
                    string toDropStr = s.substr(slideLeft, wordLen);
                    wordExist[toDropStr]++;
                    slideLeft += wordLen;
                    wordFound--;
                }
                wordExist[str]--;
                if (wordExist[str] &lt; 0) {
                    //当前字符串出现次数已满, 要不停的丢弃窗口最前端的字符串直到出现次数为0为止
                    while (wordExist[str] &lt; 0) {
                        string toDropStr = s.substr(slideLeft, wordLen);
                        wordExist[toDropStr]++;
                        slideLeft += wordLen;
                        wordFound--;
                    }
                }
                wordFound++;
                if (wordFound == wordsLen) {//找到一个要求的位置
                    ret.push_back(slideLeft);
                }
                j += wordLen;
            }
            for (; slideLeft &lt; j; slideLeft += wordLen) {
                //恢复每个单词出现的次数
                string toDropStr = s.substr(slideLeft, wordLen);
                if (wordExist.count(toDropStr)) wordExist[toDropStr]++;
            }
        }

        return ret;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/23/leetcode-29-divide-two-integers/">LeetCode 29. Divide Two Integers</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 23, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
</blockquote>
<p>不使用乘除和取模运算实现整数除法. 我的实现方法是使用位运算来实现二进制除法, 首先确定结果的符号位后取得被除数与除数的绝对值, 这样就可以只考虑原码不用考虑补码除法. 需要注意的是对于<code>INT_MIN</code>这个值(也就是-2147483648)要特殊处理, 因为它的值是这样的: <code>0x80000000</code>, 也就是只有最高位是1, <code>abs</code>函数无法对这个值取绝对值, 而且可能造成溢出问题.</p>
<p>关于二进制除法可以参考这里: <a href="http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm" target="_blank" rel="noopener">http://www.tyut.edu.cn/kecheng1/2008/site08/courseware/chapter1/1.2.htm</a></p>
<blockquote>
<p>二进制数除法与十进制数除法很类似。可先从被除数的最高位开始，将被除数（或中间余数）与除数相比较，若被除数（或中间余数）大于除数，则用被除数（或中间余数）减去除数，商为1，并得相减之后的中间余数，否则商为0。再将被除数的下一位移下补充到中间余数的末位，重复以上过程，就可得到所要求的各位商数和最终的余数。</p>
</blockquote>
<p>代码:</p>
<pre><code>class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor == 0) return INT_MAX;
        int sign = (dividend ^ divisor) &amp; 0x80000000 ? -1 : 1;
        int absDividend = abs(dividend), absDivisor = abs(divisor);
        if(dividend == INT_MIN){
            if(divisor == -1) return INT_MAX;
            else absDividend = INT_MIN;
        }
        else{
            if(absDividend &lt; absDivisor) return 0;
        }
        
        return sign * absDivid(absDividend, absDivisor);
    }
    
    int absDivid(unsigned int dividend, unsigned int divisor){
        int mDividend = getBit(dividend, 31), ret = 0;
        for(int i = 31; i &gt;= 0; i--){
            if(mDividend &gt;= divisor){
                ret |= (1 &lt;&lt; i);A
                mDividend = mDividend - divisor;
            }
            if(i != 0){
                mDividend = (mDividend &lt;&lt; 1) + getBit(dividend, i - 1);
            }
        }
        return ret;
    }
    
    int getBit(unsigned int n, int p){
        return n &amp; (1 &lt;&lt; p) ? 1 : 0;
    }
};
</code></pre>
<p>这段代码是默认<code>int</code>类型长度是4个字节.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/22/leetcode-28-implement-strstr/">LeetCode 28. Implement strStr()</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 22, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<p>实现查找子串函数. 使用双重循环.</p>
<pre><code>class Solution {
public:
    int strStr(string haystack, string needle) {
        int haylength = haystack.length(), needlelength = needle.length();
        if(haylength &lt; needlelength) return -1;
        for(int i = 0; i &lt;= haylength - needlelength; i++){
            int j;
            for(j = 0; j &lt; needlelength; j++){
                if(haystack[i + j] != needle[j]) break;
            }
            if(j == needlelength)
                return i;
        }
        
        return -1;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/21/leetcode-376-wiggle-subsequence/">LeetCode 376. Wiggle Subsequence</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 21, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p>
<p>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p>
<p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Examples:</p>
<pre><code>Input: [1,7,4,9,2,5]
Output: 6
The entire sequence is a wiggle sequence.

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
</code></pre>
<p>Follow up:
Can you do it in O(n) time?</p>
</blockquote>
<p>使用动态规划, 只需要保存当前节点与之前一个节点的信息.</p>
<pre><code>class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if(len &lt;= 2) return len;
        int maxLen = 2, diff = nums[1] - nums[0];
        for(int i = 2; i &lt; len; i++){
            int d = nums[i] - nums[i - 1];
            if(d &amp;&amp; diff &amp;&amp; ((d ^ diff) &amp; 0x80000000)){
                maxLen++;
            }
            if(d != 0){
                diff = d;
            }
        }
        return maxLen;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/21/%E5%85%B3%E4%BA%8E%E7%BB%99%E7%88%B6%E6%AF%8D%E5%88%86%E4%BA%AB%E7%85%A7%E7%89%87/">关于给父母分享照片</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 21, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>关于照片存储备份的问题, 我现在用的Google相册, 虽然按照Google的尿性说不定哪天就给关了, 但是现在用起来还是挺方便的. 但是本来应该是主要功能的照片分享功能却由于那说是不存在但是却是确确实实无处不在的GFW的原因而变得几乎不可用. 尤其是对于我父母这样别说搭梯子, 百度云都不会用(我也不敢给他们用百度)的, 分享照片更是非常麻烦.</p>
<p>我先来总结一下给我父母这样的用户分享照片所需要的服务应该有什么样的特性:</p>
<ul>
<li>访问方便, 便于查找; 也就是说可生成分享链接或者与社交网络绑定</li>
<li>国内访问速度快; 这就没有了用Google相册或者Flickr之类服务的可能</li>
<li>稳定; 谁都不想过一段时间服务就关闭了</li>
<li>要有相册管理功能, 至少缩略图之类应该具备</li>
<li>免费</li>
<li>最好有权限访问控制, 因为与父母分享的照片不少是不想公开的</li>
<li>手机访问支持比较好</li>
</ul>
<p>出于以上的几点, 我首先排除了国内的所有网盘, 因为它们基本都没有相册管理功能; 然后把目标划定在国内大型的互联网企业上. 至于iCloud, 小米, 华为等公司推出的云相册服务因为与要与设备绑定所以也排除. 百度家的东西排除, 网易相册的iOS客户端快三年没有更新了也不知道还能挺多久, 而且初始容量只有1G, 超出后只有每月300M, 有点不太够用. 至于阿里似乎没有推出过这种服务.</p>
<p>剩下的考虑企鹅, 不得不说企鹅的占有率真是厉害, 我父母手机上使用频率最高的应用就是微信了. 所以我一直用朋友圈来给父母分享一些照片. 但是这问题仍然很大, 首先是一次只能选择9张, 我一次上传一千多张根本就是不可能; 其次是微信对于图片压缩地太厉害, 基本上属于放大就不能看; 然后是没有PC端, 电脑上的许多照片不可能都传到手机上. 所以我每次都是选几张照片传上去.</p>
<p>直到昨天, 我突然心血来潮打开了尘封已久的QQ空间, 突然发现QQ空间相册竟然支持原图上传(其实我忘记了它以前支不支持), 并且有了只允许部分好友查看的功能. 突然觉得这就是我想要的与父母分享照片的工具. 父母都有QQ号并且可以通过手机QQ客户端查看; 可以保存原图, 不压缩画质(<strong>实测分辨率不变但是体积减少100-200kB左右, 并且不提供批量下载功能, 加上下载后会丢失EXIF信息, 因此不太适合做照片备份</strong>); 有访问权限控制; 国内访问速度有保障; 可以在PC端上传图片; 服务免费, 我现在有30G容量, 虽然不大, 但也勉强够用(而且不知道它是怎么计算容量的, 我昨天上传了1000+张3M左右的照片原图, 但是现在只显示用了0.4G).</p>
<p>关于安全和隐私, 企鹅虽然不能说很安全, 但是也算是有底线. 而想要隐私的话, 东西还是根本不要放到网上为好.</p>
<p>对我来说, 目前用QQ空间的相册功能算是给父母分享照片的最佳方案了.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/stl%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89-forward-list/">STL容器学习笔记三 - Forward_list</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h1 id="forward-list-前向链表-c-11"><a href="http://www.cplusplus.com/reference/forward_list/forward_list/" target="_blank" rel="noopener">Forward list</a> 前向链表[C++11]</h1>
<p>前向链表是提供常数复杂度的插入删除操作的容器, 它被实现为一个单链接链表.</p>
<p><code>forward_list</code>与<code>list</code>的区别在于前者保存指向每个节点的后一个节点的指针, 而后者保存前后两个节点的指针. <code>forward_list</code>比<code>list</code>稍微高效, 但是缺点在于只能向前遍历.</p>
<p>与其他顺序容器相比主要优点在于在容器任意位置插入, 提取和移动的表现更好. 不足在于不能根据元素在容器中的位置来访问元素.</p>
<p><code>forward_list</code>被设计得非常高效, 它与一个简单的C语言手写单向链表的效率相当. 实际上, <strong>它是唯一一个出于性能考虑而不提供<code>size</code>成员函数的标准容器</strong>.</p>
<h1 id="部分函数">部分函数</h1>
<p>只列举一些我不太熟悉的函数.</p>
<h2 id="构造函数">构造函数</h2>
<h3 id="默认构造函数">默认构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(<span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个空容器.
​</p>
<h3 id="填充构造函数">填充构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">forward_list</span> <span class="params">(size_type n, <span class="keyword">const</span> value_type&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> allocator_type&amp; alloc = allocator_type())</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个大小为n的容器, 如果提供了val, 则n个值都初始化为val.
​</p>
<h3 id="范围构造函数">范围构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">forward_list</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="title">allocator_type</span>&amp; <span class="title">alloc</span> = <span class="title">allocator_type</span>());</span></span><br></pre></td></tr></table></figure>
<p>用<code>[first, last)</code>中的数据初始化.</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst);</span><br><span class="line">forward_list (<span class="keyword">const</span> forward_list&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure>
<h3 id="移动构造函数">移动构造函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (forward_list&amp;&amp; fwdlst);</span><br><span class="line">forward_list (forward_list&amp;&amp; fwdlst, <span class="keyword">const</span> allocator_type&amp; alloc);</span><br></pre></td></tr></table></figure>
<p>除非alloc的类型与fwdlst不一致, 否则不会构造任何一个元素, 它们的所有权被直接转移.</p>
<h3 id="初始化列表">初始化列表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward_list (<span class="built_in">initializer_list</span>&lt;value_type&gt; il,</span><br><span class="line"><span class="keyword">const</span> allocator_type&amp; alloc = allocator_type());</span><br></pre></td></tr></table></figure>
<h2 id="forward-list-before-begin">forward_list::before___begin</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">before_begin</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回指向容器中首个元素之前的元素的迭代器. 该迭代器不能解引用, 主要作为成员函数<code>emplace_after</code>, <code>insert_after</code>, <code>erase_after</code>和<code>splice_after</code>的参数.</p>
<h2 id="forward-list-emplace-after">forward_list::emplace_after</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">iterator</span> <span class="title">emplace_after</span> (<span class="title">const_iterator</span> <span class="title">position</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>在position的位置之后插入元素, args为插入的新元素的初始化参数.</p>
<h2 id="forward-list-emplace-front">forward_list::emplace_front</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">emplace_front</span> (<span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
<p>在容器头部插入新元素, args为插入的新元素的初始化参数.</p>
<h2 id="forward-list-erase-after">forward_list::erase_after</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">erase_after</span> <span class="params">(const_iterator <span class="built_in">position</span>, const_iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
<p>删除容器中position之后的一个元素或者(position, last)范围内的元素.</p>
<h2 id="forward-list-merge">forward_list::merge</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(forward_list&amp;&amp; fwdlst)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">merge</span> (<span class="title">forward_list</span>&amp;&amp; <span class="title">fwdlst</span>, <span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure>
<p>根据指定顺序将fwdlst与当前容器合并.</p>
<h2 id="forward-list-remove-if">forward_list::remove_if</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">remove_if</span> (<span class="title">Predicate</span> <span class="title">pred</span>);</span></span><br></pre></td></tr></table></figure>
<p>对容器中的每个元素, 执行pred(以<code>pred(*i)</code>的形式), 如果为true则删除该元素.</p>
<p>pred可以为函数指针或者函数对象.</p>
<h2 id="forward-list-sort">forward_list::sort</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort</span> (<span class="title">Compare</span> <span class="title">comp</span>);</span></span><br></pre></td></tr></table></figure>
<p>排序函数, 该函数是稳定排序. 整个操作不包括任何的元素构造, 析构和复制. 元素只是在容器内移动.</p>
<p><strong>时间复杂度</strong>: NlogN.</p>
<h2 id="forward-list-unique">forward_list::unique</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unique</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BinaryPredicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">unique</span> (<span class="title">BinaryPredicate</span> <span class="title">binary_pred</span>);</span></span><br></pre></td></tr></table></figure>
<p>删除重复元素. <strong>这个操作只会删除与前一个元素相同的元素, 也就是说只能用于已经排序的容器.</strong></p>
<p>第二种形式中的参数binary_pred以<code>binary_pred(*i, *(i - 1))</code>的形式调用, 此函数返回true则认为两个元素相等.</p>
<p>binary_pred可以为函数指针或者函数对象.</p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array-2/">LeetCode 27. Remove Element</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>问题描述:</p>
<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,
Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>对一个有序数组去重, 并且要求不使用额外的存储空间.</p>
<p>首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.</p>
<p>接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
        }
        return num;
    }
};
</code></pre>
<p>这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.</p>
<p>首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        int maxItem = nums.empty() ? 0 : nums.back();
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
            if(nums[i] == maxItem){
                break;
            }
        }
        return num;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/leetcode-26-remove-duplicates-from-sorted-array/">LeetCode 26. Remove Duplicates from Sorted Array</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>问题描述:</p>
<blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,
Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>对一个有序数组去重, 并且要求不使用额外的存储空间.</p>
<p>首先解决的是去重的问题, 如果没有额外空间的限制, 首先想到的是创建一个新的数组, 然后遍历nums, 大于新数组末尾的数则把当前的数加入新数组. 这里数组末尾的数其实就是已经遍历过的最大值, 因此可以用一个变量来保存.</p>
<p>接下来是存储空间的问题, 由于nums中每个数在遍历时的作用只是与当前遍历过的最大值比较, 而已经遍历过的数是没有什么作用的, 所以可以使用已经遍历过的nums数所占的空间.</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
        }
        return num;
    }
};
</code></pre>
<p>这段代码的Runtime是36毫秒, 但是许多AC代码的Runtime都在32ms, 说明这个程序还有一定的优化空间.</p>
<p>首先循环体内部的操作已经非常简洁, 应该很难有所作为, 所以优化的目标应该在循环次数上. 先将nums中最大的数保存下来, 当遍历到与该值相等的时候, 把这个数处理完后就可以退出循环了. 所以最终代码:</p>
<pre><code>class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int num = 0, totalLen = nums.size(), curMax = INT_MIN;
        int maxItem = nums.empty() ? 0 : nums.back();
        for(int i = 0, j = 0; i &lt; totalLen; i++){
            if(nums[i] &gt; curMax){
                curMax = nums[i];
                num++;
                nums[j++] = nums[i];
            }
            if(nums[i] == maxItem){
                break;
            }
        }
        return num;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/20/leetcode-25-reverse-nodes-in-k-group/">LeetCode 25. Reverse Nodes in k-Group</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 20, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,
Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For k = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For k = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
</blockquote>
<p>以k个节点为一组进行顺序颠倒. 首先实现一个从某个节点开始, 把包括它的接下来的k个节点的顺序颠倒的函数, 再不断迭代这个函数直到链表末尾. 由于如果链表长度不是k的整数倍的话, 最后的<code>m(m&lt;k)</code>个元素不进行处理, 所以先计算出链表的总长度<code>len</code>, 在每次迭代时计算已经处理过的节点数<code>reversedLen</code>, 当<code>reversedLen + k &gt; len</code>时结束循环.</p>
<pre><code>/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     ListNode *next;
*     ListNode(int x) : val(x), next(NULL) {}
* };
*/
class Solution {
public:
    ListNode* reverse(ListNode* prev, int k){
        if(!prev-&gt;next) return nullptr;
        ListNode *tail = prev-&gt;next, *pPrev = tail, *pCur = pPrev-&gt;next;
        for(int i = 1; pCur &amp;&amp; i &lt; k; i++){
            ListNode *pNext = pCur-&gt;next;
            pCur-&gt;next = pPrev;
            pPrev = pCur;
            pCur = pNext;
        }
        prev-&gt;next = pPrev;
        tail-&gt;next = pCur;
        return tail;
    }
    
    int countListLength(ListNode *list){
        int len = 0;
        ListNode *p = list;
        while(p){
            len++;
            p = p-&gt;next;
        }
        return len;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        if(head == nullptr || k &lt;= 1)
            return head;
        ListNode *trueHead = new ListNode(0), *p = trueHead;
        trueHead-&gt;next = head;
        int listLen = countListLength(head);
        int reversedLen = 0;
        
        while(true){
            if(reversedLen + k &gt; listLen) break;
            p = reverse(p, k);
            reversedLen += k;
        }
        return trueHead-&gt;next;
    }
};</code></pre>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2016/07/18/leetcode-24-swap-nodes-in-pairs/">LeetCode 24. Swap Nodes in Pairs</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          Jul 18, 2016
        </span>
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>题目描述:</p>
<blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,
Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<p>交换链表相邻节点。</p>
<p>C++:</p>
<pre><code>class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
        if(head == NULL || head-&gt;next == NULL) return head;
        ListNode *first = head, *second = head-&gt;next, *prev = NULL;
        first-&gt;next = second-&gt;next;
        second-&gt;next = first;
        head = second;
        prev = first;
        first = first-&gt;next;
        while(first){
            second = first-&gt;next;
            if(second == NULL)break;
            first-&gt;next = second-&gt;next;
            second-&gt;next = first;
            prev-&gt;next = second;
            prev = first;
            first = first-&gt;next;
        }
        return head;
    }
};
</code></pre>
<p>时间4ms。</p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/page/36/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    
    
      <a class="next" href="/page/38/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>  
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:xiadong.main@gmail.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.facebook.com/xiadong1994" target="_blank" rel="noopener" class="iconfont icon-facebook" title="facebook"></a>
        
      
    
      
        
          <a href="https://www.linkedin.com/in/dong-xia" target="_blank" rel="noopener" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Shell32-Natsu" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
    
    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="friend-links">
    <span>Links:&nbsp;</span>
    
        <a href="https://wf94.github.io/" target="_blank" rel="noopener" class="friend-links-item">打满鸡血来刷题</a>
    
        <a href="http://tianyuh.com/" target="_blank" rel="noopener" class="friend-links-item">塞外麾下炙</a>
    
</div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2014 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Shell32</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.3.x"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.3.x"></script>
<script type="text/javascript">
$(function(){
    const imgs = $("img").filter(function() {
        return this.src.match(/.*\.sinaimg\.cn\/.*/);
    });
    for (let i = 0; i < imgs.length; i++) {
        let img = imgs[i];
        $(img).attr('referrerpolicy', 'no-referrer');
    }
    console.log(`Removed referrer header for ${imgs.length} sina weibo images.`);
});
</script>
    
    <!-- Go to www.addthis.com/dashboard to customize your tools --> <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-58f2179bf0859c32"></script> 
  </body>
</html>
